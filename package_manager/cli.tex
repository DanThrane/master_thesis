% Status: draft

\section{The Command Line Interface}

% We need to cover:
%
% \begin{itemize}
% \item Basic introduction of how to use the tool (we need this)
% \item Internal organization (commands)
% \item Technical architecture, and deployment
% \item Kind of wrap up how the entire thing works here
% \end{itemize}

\subsection{Internal Organization and Deployment}

The command line tool delegates most of the work to the back end service (here
called jpm). Figure \ref{fig:cli_arch} shows the architecture from the CLI's
point of view. Most noteably is the callback server, this server is responsible
for receiving information about events that occur in the back end. These are
primarily used to communicate progress, this is especially useful for long
running processes, such as downloading dependencies. The back end will in these
cases these events to a callback server, which can then choose to display
information about this event. The need for a separate service comes mostly from
a limitation in Jolie. In Jolie all communication follows either a one-way, or
request-response communication pattern. As a result of this, it isn't possible
for JPM to send back information while a request is being processed. To handle
this the front end (in this case \mintinline{text}{jpm-cli}) will inform the
back end of where it should send events.

\begin{listing}[H]
\begin{minted}{text}
                 +-------------------------------------+
                 | terminal (user)                     |
                 +-------------------------------------+
                                   |
                                   v
                 +-------------------------------------+
+------------+   |            embeds                   |
| console-ui |<--| jpm-cli ----------------+           |
+------------+   |                         |           |
+------------+   |                         v           |
| arg-parser |<--|                   +----------------+|
+------------+   |                   | callback       ||
                 |                   +----------------+|
                 +--------------------------^----------+
                                   |        |
                                   |        |
                                   v        |
                 +-------------------------------------+
                 |                jpm                  |
                 +-------------------------------------+
                     |         |         |         |
                     v         v         v         v
                 +-------+ +-------+ +-------+ +-------+
                 | reg-a | | reg-b | | reg-c | | reg-d |
                 +-------+ +-------+ +-------+ +-------+
\end{minted}
\caption{The system architecture from the CLI's point of view}
\label{fig:cli_arch}
\end{listing}

Quite a lot of services exists on the client side, notable
\mintinline{text}{jpm-cli} and \mintinline{text}{jpm}. From a usability
perspective this is less optimal. For this reason the \mintinline{text}{jpm}
binary, which ships with the package manager, will use a deployment which
embeds all of the core services together. Future versions of the package
manager, may wish to optionally spin up the required services, and run them as
daemons\footnote{A daemon is a background process running on a computer}. This
will remove quite a bit of the overhead associated with spinning up the JVM
(required for the Jolie engine) and every embedded service. Such a practice is
done by similar tools, as an example the JVM based build tool Gradle provides
such a
daemon\footnote{\url{https://docs.gradle.org/current/userguide/gradle_daemon.html}}.
This conversion would be relatively straight forward, since the server
architecture required by the daemon is already implemented.
