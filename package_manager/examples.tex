\section{Examples and Discussion}

\subsection{Creating, Sharing, Using, and Upgrading a JPM Package}

In this example we will discover the workflow of creating a package, all the
way to using this package in another project.

First we will create a new JPM package by using the \txtl{init} command.
This will display prompts which guides the user through creating a new package.
Following this a new directory is created containing the basic files needed for
a package.

\begin{minted}{text}
dan@host:/ # jpm init
Package name
------------
> my-package

( ... Remaining cut for brevity ... )

dan@host:/ # cd my-package

dan@host:/my-package # ls
package.json

dan@host:/my-package # cat package.json | json
{
  "private": false,
  "name": "my-package",
  "description": "description",
  "version": "0.1.0",
  "authors": "Dan"
}
\end{minted}

We're now ready to actually implement our service. Here we'll create a simple
service exposing an interface called \joliel{MyPackageInterface} exposing a
single operation \joliel{hello(void)(string)} which will respond back with a
greeting.

With this service created, we can now publish the package to the public JPM
registry. All JPM commands which interact with a registry optionally takes a
registry name, if this is omitted it will default to the public registry.
Before we can publish a package we must create a user on the public registry.

\begin{minted}{text}
dan@host:/my-package # jpm register
Username
--------
> dan
Password:
Password (Repeat):
\end{minted}

It's possible to ask a registry who we are currently authenticated as:

\begin{minted}{text}
dan@host:/my-package # jpm whoami
dan
\end{minted}

When authenticated, it is possible to publish package to the public JPM
registry.

\begin{minted}{text}
dan@host:/my-package # jpm publish
\end{minted}

Now lets pretend we another user, who wishes to use our package. In order to
download from the JPM public registry there is no need to be authenticated
(although other registers may require this). Lets create a package and add it
as a dependency. This requires us to update the \txtl{package.json} files
generated by JPM:

\begin{minted}{json}
{
    "dependencies": [{ "name": "my-package", "version": "0.1.X" }]
}
\end{minted}

The dependency here used the SemVer expressions explained in Section
\ref{sec:versions}. This expression states that the newest version of the
package should be picked, as long as that version has a major version number of
0 and a minor version number of 1.

We can now download all the dependencies of our package:

\begin{minted}{text}
dan@host:/client # jpm install
Downloading          my-package@0.1.0
Completed            my-package@0.1.0

dan@host:/client # tree .
.
|-- jpm_lock.json
|-- jpm_packages
|   `-- my-package
|       |-- interface.iol
|       |-- main.ol
|       `-- package.json
`-- package.json

2 directories, 5 files
\end{minted}

We can see that this generates a lockfile which states that ``my-package'' has
been resolved from the public registry as version 0.1.0.

\begin{minted}{text}
dan@host:/client # cat jpm_lock.json | json
{
  "locked": {
    "my-package@0.1.X/public": {
      "resolved": "0.1.0"
    }
  },
  "_note": "Auto-generated"
}
\end{minted}

If we publish a new version of ``my-package'' and run \txtl{install}, then
we still be left with the same version. It is not until we run \txtl{upgrade}
that we receive the newest version.

\begin{minted}{text}
dan@host:/client # jpm search my-package
my-package@0.1.1/public
  description

dan@host:/client # jpm install
Downloading          my-package@0.1.0
Completed            my-package@0.1.0

dan@host:/client # jpm upgrade

dan@host:/client # jpm install
Downloading          my-package@0.1.1
Completed            my-package@0.1.1
\end{minted}

We can start our package by setting the ``main'' attribute of the package
manifest. This allows us to write:

\begin{minted}{text}
dan@host:/client # jpm run
Service running...
\end{minted}

We can even run with a particular configuration:

\begin{minted}{text}
dan@host:/client # jpm run --conf my-profile config.col
Service running...
\end{minted}

\subsection{The Calculator System}

Continuing with the ``modularized'' version of the calculator system from
Section \ref{sec:module_examples}.

The first step in making these usable from the package manager is of course to
create package manifests. This action becomes fairly straight forward,
especially since we already have a system working with the Jolie module system.
The package manifest for the \txtl{multiplication} package is shown in Listing
\ref{lst:multiplication_package}. The only significant multiplications here are
perhaps a version number, and a formalization of dependencies (in this case the
\txtl{numbers@1.0.0} package).

\begin{listing}[H]
\begin{minted}{json}
{
    "name": "multiplication",
    "description": "An multiplication package",
    "license": "MIT",
    "authors": ["Dan Sebastian Thrane <dathr12@student.sdu.dk>"],
    "main": "main.ol",
    "version": "1.0.0",
    "dependencies": [{ "name": "numbers", "version": "1.0.0" }]
}
\end{minted}
\caption{Package manifest for the \txtl{multiplication} package}
\label{lst:multiplication_package}
\end{listing}

The other package manifests will look fairly similar. The dependency graph ends
up mimicking the system architecture exactly. However there are some subtle
problems associated with the current approach.

Currently the calculator will always download the \txtl{numbers} package,
despite not directly depending on it. This happens due to the dependency on
\txtl{multiplication} which itself depends on \txtl{numbers}. However the
\txtl{calculator} service really only depends on \txtl{numbers} if
\txtl{multiplication} is embedded. At this point this may seem like a minor
detail, but this can get vastly more complicated if there are more dependencies
(which themselves may have dependencies and so on).

The solution to this problem, is to make sure the package manager will only
download the files we actually need, and no more. This would mean if no
embedding is ever performed, we will need only the dependencies required to
perform interfacing. If embedding is required we will need both the interface
dependencies along with a concrete implementation.

For the sake of simplicity the same dependency system is used. It is
recommended that every service separately publishes its interface and concrete
implementation. This approach has the added benefit of allowing multiple
implementations of same service. For closed source services a single package
containing only the interface could be published.

Depending on if an embedding is desired the concrete implementation can simply
be listed as a dependency, the interface dependency will implicitly be picked
up (from the concrete implementation's dependencies). If an embedding is
\emph{never} desired a dependency can be made to just the interface package.

This then begs the question of when to use a concrete implementation over a
dependency. TODO say something.

Additionally JPM might benefit from optional dependencies which are only when
certain conditions are made, for example during some ``development build''.
This might prove to be a decent compromise, allowing for the convenience of
embedding without directly forcing users of the package to also depend on it.

\subsection{Using Lifetime Hooks to Improve Development Workflow}

In this example we will discover how the use of Jolie lifetime hooks can
improve the development workflow. In this example we will look at a hybrid
Jolie-Java service. The service itself will be written in Jolie, using an
internal Java service to perform some of the computational heavy-lifting.  The
\txtl{packages} service, which performs package manifest validation, used in
the package manager is an example of such a package type. The primary flow and
communication is performed entirely by Jolie, while the more ``computationally
heavy'' parts, like parsing, are handled by the internal Java service.  This
architecture is illustrated in Figure \ref{fig:jolie_java_service}.

\begin{listing}[H]
\begin{minted}{text}
+----------------------------------------+
|                                        |
| jolie-service ---------+               |
|                        | local         |
|                        | communication |
|                        |               |
|                        v               |
|                      +----------------+|
|                      | java-service   ||
|                      +----------------+|
+----------------------------------------+
\end{minted}
\caption{A Jolie service using an internal Java service}
\label{fig:jolie_java_service}
\end{listing}

The Java service uses Gradle as its build system. The build system is capable
of producing a JAR file. The Jolie engine requires this file to be included in
the classpath in order to perform the embedding. If the file is placed in the
\txtl{lib} directory this will happen automatically.

A small bash script was made to run JAR creation through Gradle, and then copy
the artifact into the \txtl{lib} directory. Interested readers may find both
the Gradle build script and bash script in Appendix 3. Both scripts are
relatively simple, but should be a sufficient starting point.

The file structure of the project is shown in Listing
\ref{lst:java_jolie_file_structure}. The \txtl{build} file is the script which
performs the entire build and copies it into the \txtl{lib} directory.

\begin{listing}[H]
\begin{minted}{text}
.
|-- build
|-- java-service
|   |-- build.gradle
|   `-- src/main/java/dk/thrane/jolie/JavaService.java
|-- main.ol
`-- package.json
\end{minted}
\caption{}
\label{lst:java_jolie_file_structure}
\end{listing}

Assuming a lot of changes are made to the Java service, this would mean two
commands would almost always be required to create a new iteration of the
build. This can be minimized by creating a \txtl{pre-start} hook as shown in
Listing \ref{lst:pre_start_hook}. Having it as a part package manifest makes
the intent very clear. Having some home-made build script would instead rely
entirely on convention. Such conventions may vary from project to project,
while having it as a part of the package manifest would remain consistent
across all JPM packages.

\begin{listing}[H]
\begin{minted}{json}
{ "events": { "pre-start": "./build" } }
\end{minted}
\caption{A \txtl{pre-start} hook for performing compilation of the internal
    Java-service}
\label{lst:pre_start_hook}
\end{listing}

The JPM lifetime hooks aim to enforce the implicit workflow a project typically
has by making it explicit. This could for example be used to enforce the
constraint that testing must succeed before publishing to a registry. This can
be implemented by using the \txtl{pre-publish} hook. If the script being run
returns a non-zero exist code, then the publishing action will be canceled
(similar behavior applies to all \txtl{pre-*} hooks).

Currently however it would be useful if a Jolie package could allow for
multiple entry-points. This would make it easier to write tests written
directly in Jolie. However having multiple entry-points would bring up the
question of which to use for embedding. We could keep the constraint of a
single main entry-point used for embedding, and multiple others used for
various other tasks, such as testing.
