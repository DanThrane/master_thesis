\section{Modules: Design and Implementation}

The module system of Jolie is made to facilitate better options for
modularizing code. This will allow for a package manager to exist.  We define a
module in Jolie is defined as a project root directory, and optionally an
entry-point. Modules are uniquely identified by a name.

The Jolie engine needs to know about these modules. The engine is informed
about these modules from the intent, passed as options, which starts the
engine. This information is collected in the ``intent parsing'' phase, and is
made available to any later phase that might need it.  Since the intent is
passed as an option, all interpreter instances inside the engine will know
about each module.  As a result any embedded service will also be aware of the
same modules.

Consider a module ``foo'', with its source code placed at \txtl{/packages/foo}
and an entry-point at \txtl{/packages/foo/main.ol}. It is possible to inform a
Jolie interpreter about this module using
\txtl{--modfoo,/packages/foo,main.ol}.

The result of this decision is that quite a lot of additional options may need
to be passed to the engine. However this choice was purposely chosen, it is
left for another tool to make this job easier. In this case a package manager
is expected to take the heavy lifting, and figure out which modules exists.
This allows for more freedom in how these tools are implemented, and another
implementation strategy, than the one provided in the package manager, could be
created without any changes to the language infrastructure. See Section TODO
about how the package manager passes this information to the engine.

To allow for better organization, a new type of include has been added to the
language. These include allows the developer to include from a particular
package. The syntax of this include is shown in Listing \ref{lst:mod_include}.
When a package include is used, the search path will be altered, such that the
project root is changed to that of the package (as opposed to where the engine
was started). Any file included from within this package should perform its
includes relative to its own root, rather than the project root.

The new include syntax, along with native support for modules, allows for the
code to properly organized. With this a module may be placed inside of its own
directory, without any of the code having to be changed.

\begin{listing}[H]
\begin{minted}{jolie}
include "<file>" from "<module>"
\end{minted}
\caption{Extension to the include statement, made for module imports}
\label{lst:mod_include}
\end{listing}

\subsection{Module Include Algorithm}

A module include is an extension of ordinary includes which specify which
module to perform the inclusion from, that is \joliel{include "file" from
"module"}.

The simple case of such an include is fairly simple. We make a ``context
switch'' our working directory into the root of the module and start searching
for the file in that folder. This works quite well, however consider the
following scenario. From a client we perform a package include: \joliel{include
    "interface.iol" from "dependency"}. The source code of this file is shown
Listing \ref{lst:dependency_include}.

\begin{listing}[H]
\begin{minted}{java}
/* /dependency/interface.iol */
include "types.iol"

interface Dependency { /* ... */ }

/* /dependency/types.iol */
type SomeRequest: void { /* ... */ }
\end{minted}

\caption{Module includes may cause more ordinary includes. We must make sure
    the switch in context is kept}

\label{lst:dependency_include}
\end{listing}

With the current code this would cause the system to incorrectly look for
\txtl{types.iol} in the current working directory! To fix this a stack is kept.
This stack gains an entry when a module include is performed, this entry is
popped off the stack once the contents of that include has finished parsing.
The stack is then used to inject the module's root into the search path for the
ordinary includes.
