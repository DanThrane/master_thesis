\section{Configuration}
\label{sec:col}

% TODO Define configuration and which constructs we want to be configurable

From observation 2 we saw that most configuration was done via the inclusion of
source code. This source code would expose constants (read: literal values
\emph{and} identifiers). The included source code, however, can do anything
that Jolie source normally can, and isn't limited to just the desired
configuration. As a result, a service developer cannot be certain that the
configurator (entity who provides configuration) doesn't start messing with
other details of the program. Deploying defensive
programming\footnote{Defensive programming techniques are usually employed for
systems that require high availability, or where safety and security is
required.} techniques against this becomes significantly more problematic,
since no guarantees about the configuration source file can really be made.

Distributing re-useable packages is also problematic with this approach.
Several features of package management requires that the package remains
read-only. For example, updating of packages require this, without it
source-code merges would be required.

We also saw that a lot of issues, that should have been a deployment issue,
became a code issue.

This gives us plenty of reason to explore the need for a native configuration
format.  Most other systems would most likely go for a system defined in user
code, as opposed to natively. An example of such framework, could be Vert.x, it
is a tool-kit for building reactive applications on the JVM.  Examples of such
``reactive applications'' are microservices. The configuration workflow is
shown in Figure \ref{fig:normal_conf}. The system will retrieve, and read
external configuration files, directed by the user code, and apply the
configuration as needed.

% Most other systems can do this at run time
% For example Vert.x does this by reading external configuration files
% Once configuration is done, we can start up the server

\begin{listing}[H]
\begin{minted}{text}
+------------------+     +-------------------+     +--------------------+
| executable start | --> | retrieve conf     | --> | read conf files    |
+------------------+     +-------------------+     +--------------------+
                                                             |
                            +-----+                          |
                            |     | reconfigure              |
                            |     v                          v
                         +-------------------+     +--------------------+
                         | server running    | <-- | perform conf       |
                         +-------------------+     +--------------------+
\end{minted}
\caption{Simplified workflow for configuration of Vert.x applications}
\label{fig:normal_conf}
\end{listing}

% http://vertx.io/blog/vert-x-application-configuration/
% http://vertx.io/docs/vertx-config/kotlin/

TODO Defined deployment time somewhere

However implementing such as a system in Jolie has its problems, most of these
come from the difference between general-purpose programming languages and
specialized programming languages.

In general-purpose languages, the constructs (such as a server's socket) for
the microservice architecture are created in user code. As a result they are
entirely accessible from user code. This make it feasible to change their
behaviour, since code can run before deployment occurs.

In Jolie the constructs are managed directly by Jolie. Doing this has multiple
advantages, such as less complexity in user code, but it also means that user
code is capable of doing less. Jolie user code can for example not control
networking directly, but is instead forced to use the abstractions provided by
Jolie (sending messages). The language puts constraints on certain constructs
being fully prepared directly in the source code. This is analogous to a
programming language requiring the types of a struct's field to be present at
compile time. As a result, not all constructs can be changed at run time.
Concrete examples of this includes the input ports, which needs to be ready at
deployment time. Thus without native support for configuration of these, it
would not be possible to change the input port.

\subsection{Introducing the Jolie Configuration Format}
\label{sec:conf_units}

In the coming section we will cover the Jolie Configuration Format (file
extension: \txtl{.col}). The configuration format is build to solve the issues
highlighted in the previous section.

% Goals

This new configuration format should allow a developer to provide configuration
for a service, which works in the setting of packaged services. This will
entirely replace the old system of using a mix of constants and hard-coded
values.

The configuration system will only allow configuration of constructs which has
been marked as such by the module. This should also allow a developer, and
potentially tools, to quickly identify which constructs allow configuration.
As much as possible the code should act as documentation of itself.

Additionally the system should work with the existing checking tools (e.g. the
\txtl{--check} flag). The checking tools of Jolie are, for example, used by
editor plugins to show errors. These checks do not execute any code. The
checking algorithm should check that configuration is valid. Additional
arguments can be added at a later point, which may configure if missing
configuration should be considered an error.

% Basic concepts and example

A configuration file is build up of \emph{configuration units}.  A
configuration unit is the basic entity, which encapsulates the configuration of
a single Jolie module.

A unit is uniquely identified by its profile name and module. Having multiple
profiles for the same module can be useful for a variety of use-cases. A common
use-case, could for example be to have separate profiles for development and
production.

The units hold configuration for every possible type of configurable construct
in Jolie. The ones supported are:

\begin{enumerate}
    \item Input and output ports
        \begin{itemize}
            \item Location
            \item Protocol and protocol parameters
            \item Embedding of other services (output ports only)
        \end{itemize}
    \item General purpose parameters (constant values accessible from
            Jolie programs)
    \item Interface rebinding
\end{enumerate}

We'll introduce the configuration format through examples. The configuration
format is custom, and made to mimic the syntax of Jolie.

Listing \ref{lst:simple_conf} shows a very simple configuration unit. This
units sets the location and protocol for the output port \joliel{A} (line 3 and
        4), the location of the input port \joliel{ModuleInput} (line 8), and
two parameter assignments (line 11 and 12).

\begin{listing}[H]
\begin{minted}{jolie}
profile "hello-world" configures "my-module" {
    outputPort A {
        Location: "socket://a.example.com:3000"
        Protocol: sodep { .keepAlive = true }
    },

    inputPort ModuleInput {
        Location: "socket://localhost:80"
    },

    myParameter = 42,
    myParameter.subProperty = "hello"
}
\end{minted}

\caption{A simple configuration unit named \joliel{hello-world}
    configuring the module \joliel{my-module}}

\label{lst:simple_conf}

\end{listing}

Embedding of output ports can be performed from within a configuration unit.
This moves the embedding from being a code problem to, what it should have
been, a deployment problem.

Listing \ref{lst:conf_embedding} shows the embedding of output port \joliel{A}.
Note that we need to make a reference to the module, since the profile names
are placed under a namespace for each module. This way multiple services can
share the same name, a situation which is likely to occur with common profile
names, such as ``development'' and ``production''.

\begin{listing}[H]
\begin{minted}{jolie}
profile "hello-world" configures "my-module" {
    outputPort A embeds "a-module" with "a-profile"
}

profile "a-profile" configures "a-module" {
    // configuration of a-module goes here.
}
\end{minted}
\caption{Embeddings make reference to other configuration units}
\label{lst:conf_embedding}
\end{listing}

As seen in the examples, it is okay to provide partial configuration as opposed
to complete configuration. Certain values may be provided by the underlying
module, which uses this unit. In that case the configuration unit cannot
override it.  In other cases partial configuration is okay due to profiles
extending other profiles.

A configuration unit may extend another unit. The two, however, must configures
the same module. The inheritance tree may be of an arbitrary depth, but
each unit may only extend a single unit, and they must configure the same
module.

If the child and parent disagree on configuration, the child always decides.
For example, if unit ``B'' extends ``A'', and they both configure the same
value, then the values found in B are the ones that are correct. Listing
\ref{lst:conf_extends} shows an example of inheritance.

\begin{listing}[H]
\begin{minted}{jolie}
profile "a" configures "a-module" {
    aValue = 42,
    aValue.sub = "hello",

    outputPort ExternalService {
        Location: "socket://external.example.com:42000"
    }
}

profile "b" configures "a-module" extends "a" {
    aValue = 100
    // aValue.sub = "hello"
    // ExternalService.location = "socket://external.example.com:42000"
}
\end{minted}
\caption{Configuration units may extend other units}
\label{lst:conf_extends}
\end{listing}

The module developer is often aware of what the defaults should be. For this
reason default configuration profiles may be shipped along the modules, which
are implicitly imported into every configuration file. The Jolie engine will
look for any \txtl{.col} file in the \txtl{conf} folder. This folder should be
placed relative to the module's root. For example, if module "a" has a file
called \txtl{conf/my-defaults.col}, which contains a unit called "default".
Then the user of the package may either write a configuration unit which
extends this, simply by writing \joliel{profile "something" configures "a"
    extends "default"}, or the default directly. There is no need for any
    inclusion of this file.

It should be noted that no single unit is required to provide all
configuration. The system doesn't have any ``abstract''\footnote{As in abstract
classes, a concept often used in object oriented programming} configuration
units. However it is required that the configuration file provides all the
necessary configuration, as declared by the module.

\subsection{Input and Output Ports}

% TODO Need to clean this up.
%
% 1. Present solution
% 2. Discuss problems

Input and output ports, both existing constructs, are defined just like before
in the Jolie code.

Externally configurable ports are defined by leaving out fields that should be
configurable. Listing \ref{lst:configurable_input} shows a configurable input
port.

Only the fields which are not already listed become configurable. This is
useful when building a service that needs to make assumptions about its input
ports. For example if a developer is building a generic web-server, it is
useful to allow the developer to change the location, but the protocol should
be fixed.

One typical assumption that Jolie services make about their input ports come
from aliases that are made in the protocol configuration, an example is shown
in line 4 of Listing \ref{lst:configurable_input}. The pointer statement takes
two variable paths, and makes the one on the left link to the one on the right.
The result of this pointer alias is that any operation running from that input
port will be able to set the variable \txtl{statusCode} and the status code of
the HTTP request will be set appropriately. It should also be noted that the
configuration units \emph{do not} support aliases, and there are no other ways
of accessing variables hidden in the protocol configuration. As a result any
service which needs to do something special with its protocol configuration,
like aliasing, must do it in source code. Since the aliased variable now also
takes on a new semantic meaning, it also makes sense that it must be named
directly in source code, and not left to configuration, where it could take
any arbitrary name.

\begin{listing}[H]
\begin{minted}{jolie}
inputPort MyWebServer {
    Protocol: http {
        .keepAlive = true;
        .statusCode -> statusCode;
    }
    Interfaces: MyWebServerInterface
}
\end{minted}
\caption{A bare-bones configurable input port for a web-server}
\label{lst:configurable_input}
\end{listing}

If instead, all values could be overwritten of a port then the underlying
service would not be able to make assumptions about the additional features
provided by, for example, its protocol. For this reason only values not
specified can be overwritten.

However simply leaving out fields, and assuming they must be configurable
proves somewhat problematic for output ports. Output ports require no fields,
other than the interfaces, to be defined at deployment time. It is quite
common for dynamic ports to not add a default location or protocol,
assuming it is changed before use. To deal with this problem, it was
decided to add a new keyword (\joliel{dynamic}) for output ports which
need to change their location and protocol dynamically. Only output
ports marked with this keyword are allowed to be changed at run-time.
Dynamic ports are also not configurable.

\subsection{Parameters}

Parameters are read-only values which are provided to a Jolie module at
deployment time. A parameter is type-checked at deployment time, to ensure that
its type matches what the underlying service expects. Listing \ref{lst:params}
shows a parameter definition and its use.

The type-checking feature functions both as a mean of documentation and
ensuring that the supplied configuration is valid. Like any other type-checked
feature of Jolie, it is possible to opt-out simply be setting the type to be
\txtl{undefined}.

\begin{listing}[H]
\begin{multicols}{2}
\begin{minted}[breaklines,fontsize=\footnotesize]{jolie}
// service.ol
parameters {
    myParameter: string {
       .foo: int
       .bar: bool
    }
}

main {
    println@Console(myParameter)(); // "Root"
    println@Console(myParameter.foo)(); // 42
    println@Console(myParameter.bar)() // false
}
\end{minted}

\columnbreak

\begin{minted}[breaklines,fontsize=\footnotesize]{jolie}
// service.col
profile "my-profile" configures "service" {
    myParameter = "Root",
    myParameter.foo = 42,
    myParameter.bar = false
}
\end{minted}

\end{multicols}
\caption{A parameter definition and its use}
\label{lst:params}
\end{listing}

From a high-level point of view, parameters are very similar to constants.
However parameters weren't implemented as an extension of constants due to
their technical implementation. Namely constants aren't implemented using the
``Value'' system, which is used by all variables and messages in Jolie, but
rather implemented at the parser level.

When the Jolie parser encounters a constant definition, it will save the token
from the assignment and associate it with the identifier on the left hand side.
Only identifier tokens and simple value tokens are allowed. The constant
definitions are limited to only a single token. As a result it isn't possible
to define more advanced tree-like values, which parameters such as
\joliel{myParameter} from Listing \ref{lst:params} would require.

Whenever the parser reaches a places where a constant would be allowed, it will
look at the next token, check if it is an identifier, and try to replace the
current token with the token defined by the constant. This produces some rather
surprising results and has limitations, which isn't commonly found in other
programming languages.  Listing \ref{lst:jolie_constants} illustrates how the
Jolie parser processes constants.

\begin{listing}[H]
\begin{multicols}{2}

\begin{minted}[breaklines,fontsize=\footnotesize]{jolie}
constants {
    FOO = 42
    BAR = ActualInterface
}

init {
    println@Console(FOO)()
}

courier Foo {
    [interface BAR(req)(res) {
        /* ... */
    }]
}
\end{minted}

\columnbreak

\begin{minted}[breaklines,fontsize=\footnotesize]{jolie}
init {
    println@Console(42)()
}

courier Foo {
    [interface ActualInterface(req)(res) {
        /* ... */
    }]
}
\end{minted}

\end{multicols}

\caption{Constants in Jolie works by replacing tokens at the parser level. Left:
    The input program. Right: The program which the parser ends up seeing}

\label{lst:jolie_constants}

\end{listing}

While it would have been possible to extend the value system to support values
it was ultimately decided against. Adding both optional type-checking of
constants and expanding to values was seen as too big a departure from the
original intent of constants. For backward compatibility reasons constants
would also still not have been pure values, but rather either an identifier or
a value.

The new parameters block is an addition to the AST of Jolie programs. This
addition currently only works in collaboration with the configuration and
module system. The block is simply not valid to use without. If any parameter
is not defined by configuration or has the wrong type the checking scripts of
Jolie will throw an error.

Even though the parameters block is added to the AST it will not be visible in
the final interpretation tree. We'll learn more about this in Section
\ref{sec:col_impl}.

\input{modules/interface_rebinding.tex}

\subsection{Syntax of the Configuration Format (COL)}

In this section the formal grammar of the configuration format is presented.
The grammar is presented in a ABNF-like syntax. Complete syntax is presented in
Appendix B.

All literals are case sensitive.

TODO is ABNF okay considering it is mostly used for communication protocols?

A configuration file starts by a list of includes, followed by a list of
regions.

\begin{minted}{abnf}
configuration-tree = *include *region

include = "include" qstring

region = region-header "{" region-body "}"
region-header = [ "profile" qstring ] "configures" qstring
                [ "extends" qstring ]
region-body = *definition
definition = port | interface | parameter
\end{minted}

The definitions inside of a region correspond to the different configurable
units. The syntax is made to closely mimic the syntax of existing Jolie code.

\begin{minted}{abnf}
port = input-port | output-port
input-port = "inputPort" identifier "{" port-body "}"
output-port = embedded-output-port | external-output-port
external-output-port = "outputPort" identifier "{" port-body "}"
embedded-output-port = "outputPort" identifier "embeds" qstring
                       "with" qstring
port-body = *port-property
port-property = location-property | protocol-property
location-property = "Location" ":" qstring
protocol-property = "Protocol" ":" identifier [ protocol-config ]
protocol-config = inline-tree

interface = "interface" identifier "=" identifier "from" qstring

parameter = variable-path "=" value
variable-path = var-id *var-node
var-id = ( "(" qstring ")" ) | identifier
var-node = "." var-id [ "[" unsigned-int "]"  ]
value = ( primitive [ inline-tree ] ) | inline-tree
inline-tree = "{" *(tree-child ",") tree-child "}"
tree-child = "." variable-path "=" value
primitive = qstring | int | long | double | bool
\end{minted}

The values very closely resemble what Jolie allows, primarily just removing
variables from the syntax. Variable identifiers can be strings, like in Jolie,
to allow for special variable names which would otherwise not be
valid identifiers. This is primarily useful for building dictionary like
structures with arbitrary string keys.

Additional configuration file supports C-style comments, these are allowed
anywhere and are simply ignored.

\begin{minted}{abnf}
comment = single-line-comment | multi-line-comment
single-line-comment = "//" <any text except line breaks>
multi-line-comment = "/*" <any text except "*/"> "*/"
\end{minted}

